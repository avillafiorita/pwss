h1. Pwss

A password manager in the spirit of "pws":https://github.com/janlelis/pws.

Features:

* Each entry stores: title, username, password, url, description
* A file (or safe) can store many entries
* The user can manage different files (safes)
* CRUD (create, read, update, delete) commands are available to
  operate on entries and safes
* pwss can generate completely random passwords for you
* Safes can be encrypted (to improve security)
* Encrypted safes can be decrypted (for instance to batch process
  entries, to migrate to another tool, or to manually edit entries)
* Entries are human readable and editable (when not encrypted)

h2. Installation

Add this line to your application's Gemfile:

bc. gem 'pwss'

And then execute:

bc. $ bundle

Or install it yourself as:

bc. $ gem install pwss

h2. Usage

*Getting started.* @pwss@ stores passwords in a YAML file (also called "password safe" in the following), possibly encrypted.

A typical usage scenario is the following:

# @pwss init@ will create a new encrypted password safe in @~/.pwss.yaml.enc@
# @pwss add@ will add a new entry to the file
# @pwss get entry@ will retrieve all entries whose *title* contains @entry@ and make the password of the chosen entry available in the clipboard

*Using multiple safes.* If you want to create multiple password safes or store the password safe in a non-standard location, use the @-f@ (@--filename@) option:

# @pwss -f MYFILE init@
# @pwss -f MYFILE add@
# @pwss -f MYFILE get@

*Controlling how long passwords are made available* Use the @-w@ option to determine how long the password is made available in the clipboard.  For instance:

bc. $ pwss get my_email -w 3

will retrieve entry whose title is @my_email@ and make the password available in the clipboard for @2@ seconds.

Use @0@ to keep the password in the clipboard till a key is pressed.

*Automatically Generated Password* pwss can automatically generate passwords for entries which are added or updated, using the @-g LENGTH@ option, where @LENGTH@ is the length of the password to generate.  If you want to generate password including only alphabetic and numeric characters, use the @-a@ option.  *The passwords are made available in the clipboard, so that it can be used as needed*.

For instance:

bc. $ pwss update my_email -g 10 -a -w 20

will update the @my_email@ entry, by replacing the existing password with one of length @10@ automatically generated by @pwss@; the password contains only alphabetic characters and digits.  The new password will be made available in the clipboard for @20@ seconds.

*Encrypted and Plain Files.* @pwss@ works equally well with encrypted and plain files.  More in details, the file extension determines whether @pwss@ tries to decrypt/encrypt the file or not.  The @.enc@ extension tells @pwss@ that the file is encrypted; any other extension will tell @pwss@ to treat the file as plain text.

For instance:

bc. $ pwss -f a.yaml.enc init 

will store the password in the *encrypted* file @a.yaml.enc@.

By contrast,

bc. $ pwss -f a.yaml get entry

will try to retrieve @entry@ from file @a.yaml@; the file is assumed to be in plain text by @pwss@ which will not ask for a master password, nor will try to decrypt it.

Encrypting important passwords is a good idea. (Just in case you were looking for a witty statement.)  However, if you use @pwss@ to store non-critical infomation, prefer to edit the password safe with a text editor, or use another application for managing encryption and decryption, using @pwss@ with the file in plain format might be more convenient.

*Moving from plain to encrypted.* Use the @encrypt@ and @decrypt@ commands at any time to move from the plain to the encrypted format.

bc. $ pwss -f YOURFILE encrypt 

will encrypt @YOURFILE@ while @decrypt@ will perform the opposite operation.

*Starting from an Existing File.*  You can also start from an existing file, as long as it is an array of YAML records, each containing, at least, a @title@ and a @password@ field.  (See next section, for the file structure.)

In this scenario, you can use the following commands to get started:

# @pwss -f YOURFILE encrypt@ will encrypt your existing password file
# @mv YOURFILE.enc ~/.pwss.yaml.enc@ moves the encrypted file to the default location (not necessary, but it simplifies the workflow)

To add entries to the password safe, use the @add@ command.  If you prefer to operate on the file using a text editor, you can also use the @decrypt@ and @encrypt@ commands.

*Defining your entries.*  @pwss@ requires entries to have only a @title@ and a @password@ field.  If you want you can define and store your own records in the yaml files.

*Getting Help.*

bc. $ pwss

will show all command options.

h2. Under the Hood

@pwss@ adopts a human-readable format for storing passwords, when the file is not encrypted, of course! (Unless you have mathematical super-powers and can read encrypted text.)

The password files is a YAML file containing an array of entries.  By default, entries have the following records:

* title
* username
* password
* url
* description

Example

<pre>
- title: A webservice
  username: username@example.com
  password: 1234567890
  url: http://www.example.com
  description: >
    with a password like the one above, who needs a password safe

- title: My email
  username: username@example.com
  password: 1234567890
  url: http://www.example.com
  description: >
    Also available via email client, with the following connection parameters
    smtp.example.com
    imap.example.com
</pre>

Notice that only @title@ and @password@ are required.

h2. Changelog

* *Release 0.1.0*
** the update command now allows one to update the password or any other field of existing entries
** a simple password generator allows pwss to generate a random password
** most commands make the password of the selected entry available in the clipboard (useful, for instance, if you automatically generate a password)
** a destroy command allows one to delete an entry from a safe.  Similar to get, all entries matching a query are shown.  The user is then asked to select which entry has to be deleted or stop.  User confirmation is required even in case of a single match.

h2. License and Additional Disclaimer

Licensed under the terms of the MIT License.

h2. Contributing

1. Fork it ( http://github.com/<my-github-username>/pwss/fork )
2. Create your feature branch (`git checkout -b my-new-feature`)
3. Commit your changes (`git commit -am 'Add some feature'`)
4. Push to the branch (`git push origin my-new-feature`)
5. Create new Pull Request
