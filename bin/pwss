#!/usr/bin/env ruby

require 'fileutils'
require 'mercenary'
require 'date'

require "pwss"
require "pwss/version"
require "pwss/cipher"
require "pwss/entry"
require "pwss/fileops"

Mercenary.program(:pwss) do |p|
  DEFAULT_FILENAME = File.join(Dir.home, ".pwss.yaml.enc")

  p.version Pwss::VERSION
  p.description <<EOS
PWSS is a password safe, in the spirit of pws

Features:

* Each entry stores: title, username, password, url, description
* A file (or safe) can store many entries
* The user can manage different files (safes)
* CRUD (create, read, update, delete) commands are available to
  operate on entries and safes
* Safes can be encrypted (to improve security)
* Encrypted safes can be decrypted (for instance to batch process
  entries, to migrate to another tool, or to manually edit entries)
* Entries are human readable and editable (when not encrypted)
EOS

  p.syntax "pwss [global option] <subcommand> [options] args"
  p.option 'filename', '-f FILE', '--filename FILE', 'Password file'
  p.option "generate", "-g LENGTH", "--generate LENGTH", "generate a password of length LENGTH"
  p.option "alnum", "-a", "--alnum", "use only alphabetic and numeric characters for the generated password"
  p.option 'wait', '-w SECONDS', '--wait SECONDS', 'Number of seconds password is available in the clipboard (use 0 for interactive).'
  p.option 'field', '--field FIELD', 'Field to update (if not specified, update the password field)'

  p.command(:init) do |c|
    c.syntax "init"
    c.description "Init a new password file (= password safe)"
      
    c.action do |args, opts|
      filename = opts['filename']  || DEFAULT_FILENAME

      empty_safe = "# safe created on #{Date.today}\n"

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        password = Cipher::check_password
        new_string = Cipher::encrypt empty_safe, password
      else
        new_string = empty_safe
      end

      FileOps::backup(filename) if File.exists?(filename)
      FileOps::save filename, new_string

      puts "New safe created in #{filename}"
    end
  end

  p.command(:list) do |c|
    c.syntax "list all entries"
    c.description "List all entries in a safe"
      
    c.action do |args, opts|
      filename = opts['filename']  || DEFAULT_FILENAME

      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      Pwss::list entries
    end
  end

  p.command(:get) do |c|
    c.syntax "get string"
    c.description "Get password for entry matching string in title"

    c.action do |args, opts|
      filename = opts['filename'] || DEFAULT_FILENAME
      waiting = opts['wait'] ? opts['wait'].to_i : 30
      
      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      password = Pwss::get args.join(" "), entries
      Cipher.password_to_clipboard password, waiting
    end
  end

  p.command(:add) do |c|
    c.syntax "add an entry"
    c.description "Add an entry to a password safe"
      
    c.action do |args, opts|
      filename = opts['filename'] || DEFAULT_FILENAME
      waiting = opts['wait'] ? opts['wait'].to_i : 30
      length = opts['generate'] ? opts['generate'].to_i : 0

      string, password = file2string filename

      # ask for a new entry
      pe = Pwss::Entry.new
      pe.ask length, opts['alnum']

      # add the entry to the safe
      entries = YAML::load(string) || Array.new
      entries << pe.entry

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry added."
      
      # make password available in the clipboard
      Cipher.password_to_clipboard pe.entry["password"], waiting
    end
  end

  p.command(:update) do |c|
    c.syntax "update the password of an existing entry"
    c.description "Update the password of an existing entry"

    c.action do |args, opts|
      filename = opts['filename'] || DEFAULT_FILENAME
      waiting = opts['wait'] ? opts['wait'].to_i : 30
      length = opts['generate'] ? opts['generate'].to_i : 0
      field = opts['field']

      string, password = file2string filename

      # load entries and update 
      entries = YAML::load(string) || Array.new

      if field then
        entries, entry_password = Pwss::update_field args.join(" "), entries, field
      else
        # update password
        entries, entry_password = Pwss::update args.join(" "), entries, length, opts["alnum"]
      end

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry updated."

      # copy to clipboard the new password
      Cipher.password_to_clipboard entry_password, waiting
    end
  end    


  p.command(:destroy) do |c|
    c.syntax "delete an entry"
    c.description "Permenently delete an entry from a safe"
      
    c.action do |args, opts|
      filename = opts['filename'] || DEFAULT_FILENAME

      string, password = file2string filename
      entries = YAML::load(string)

      entries = Pwss::destroy args.join(" "), entries
      
      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry deleted."
    end
  end
  

  #
  # Operations on the master file
  #

  p.command(:encrypt) do |c|
    c.syntax "encrypt"
    c.description "Encrypt a password safe"
      
    c.action do |_, opts|
      filename = opts['filename'] || DEFAULT_FILENAME.sub(/\.enc$/, "")

      password = Cipher::check_password
      data = FileOps::load filename
      encrypted = Cipher::encrypt data, password

      enc_filename = filename + ".enc"
      FileOps::save enc_filename, encrypted
      puts "An encrypted copy now lives in #{enc_filename}"
      puts "You might want to check everything is ok and delete the plain file: #{filename}"
    end
  end

  p.command(:decrypt) do |c|
    c.syntax "decrypt"
    c.description "Decrypt a password safe"
      
    c.action do |_, opts|
      filename = opts['filename'] || DEFAULT_FILENAME

      password = Cipher::ask_password
      data = FileOps::load filename
      decrypted = Cipher::decrypt data, password

      dec_filename = filename.sub(/\.enc$/,"")
      FileOps::save dec_filename, decrypted
      puts "A decrypted copy now lives in #{dec_filename}"
      puts "You might want to check everything is ok and delete #{filename}, if you wish."
    end
  end

  p.command(:help) do |c|
    c.action do |_,_|
      puts p.to_s
    end
  end

  p.default_command(:help)

  # load filename and decrypt, if necessary
  # return the filename as string and the password (in case you need to save)
  def file2string filename
    string = FileOps::load filename
    if FileOps::encrypted? filename then
      password = Cipher::ask_password
      string = Cipher::decrypt string, password
    end
    [string, password]
  end
end
