#!/usr/bin/env ruby

require 'fileutils'
require 'slop'
require 'date'

require "pwss"
require "pwss/version"
require "pwss/cipher"
require "pwss/entry"
require "pwss/credit_card"
require "pwss/bank_account"
require "pwss/software_license"
require "pwss/fileops"

# load filename and decrypt, if necessary
# return the filename as string and the password (in case you need to save)
def file2string filename
  string = FileOps::load filename
  if FileOps::encrypted? filename then
    password = Cipher::ask_password
    string = Cipher::decrypt string, password
  end
  [string, password]
end

# this is to support command aliases: add and new
# maybe not the the best of places where to define a function
def add opts, args
  filename = opts.to_hash[:filename] || DEFAULT_FILENAME
  waiting  = opts.to_hash[:wait]     || DEFAULT_SECS
  length   = opts.to_hash[:generate] || 0
  type     = opts.to_hash[:type]     || "Entry"
  alnum    = opts.to_hash[:alnum]

  default_title = args.join(" ")
  string, password = file2string filename

  puts "Adding #{default_title != "" ? "entry '" + default_title + "'" : "an entry"} of type '#{type}' to #{filename}"
  # ask for a new entry
  if default_title != "" then
    overrides = {"title" => ["Readline.readline('title (leave empty for \"#{default_title}\"): ')", "'#{default_title}'"]}
  end
  pe = eval("Pwss::" + type).new
  pe.ask length, alnum, overrides

  # add the entry to the safe
  entries = YAML::load(string) || Array.new
  entries << pe.entry

  # check status of input file and encrypt if necessary
  if FileOps::encrypted? filename then
    new_string = Cipher::encrypt entries.to_yaml, password
  else
    new_string = entries.to_yaml
  end

  FileOps::backup filename
  FileOps::save filename, new_string

  puts "Entry added."
  
  # make password available in the clipboard, if there is a password to make available
  if pe.entry["password"] 
    Cipher.password_to_clipboard pe.entry["password"], waiting
  end
end

version = Pwss::VERSION
man = <<EOS
NAME
  pwss -- A command-line password manager

SYNOPSYS
  pwss [-h|-v]
  pwss command [options] [args]

DESCRIPTION
  PWSS is a password manager, in the spirit of pws.

  Features:

  * PWSS manages password *files*:
    - A password file can store different entries (password and other
      sensitive information)
    - The user can manage different password files (e.g., work, personal)

  * Entries in a password file can be any of Entry, CreditCard, BankAccount, 
    SoftwareLicense.  Each type stores a different set of infos:

    - Entry:           title, username, password, url, description
    - CreditCard:      title, issuer, name_on_card, card_number, valid_from, 
                       valid_till, verification_number, pin, url, notes
    - BankAccount:     title, name, iban, url, description
    - SoftwareLicense: title, version, license_number, licensed_to,
                       email, purchased_on

  * Password files can be encrypted

  * Encrypted password files can be decrypted, for instance, to batch process
    entries, to migrate to another tool, or to manually edit entries

  * Entries are human-readable (and editable), when the password file is not
    encrypted

EXAMPLES
  pwss -h                               # get syntax of each command

  # scenario
  pwss init -f a.enc                    # generate an encrypted safe a.enc
  pwss add -f a.enc -g 16 -a            # add an entry (pwss will generate a random 16-char password)
  pwss get -f a.enc my secret account   # find an entry

VERSION
  This is version #{version}

LICENSE
  MIT

SEE ALSO
  pwss -h
  pwss man
  https://github.com/avillafiorita/pwss
EOS



#
# Main App Starts Here!
#
cmd = nil
opts = Slop.parse :help => true, :strict => true do
  # the default filename
  DEFAULT_FILENAME = File.join(Dir.home, ".pwss.yaml.enc")
  # the default number of seconds password is available in the clipboard
  DEFAULT_SECS = 30

  banner "pwss [-h|-v]\npwss command [options] [args]"

  ##############################################################################
  on "-v", "--version", 'Print version information' do
    cmd = "version"
    puts "pwss version #{version}"
  end

  ##############################################################################
  command :man do
    banner "pwss man"
    description "Print detailed information about how to use pwss"

    run do |_, _|
      cmd = "man"
      puts man
    end
  end

  ##############################################################################
  command :init do
    banner "pwss init [options]"
    description "Init a new password file"

    on "-f", "--filename=", "Password file to create. Use extension '.enc' to encrypt it."

    run do |opts, args|
      cmd = "init"
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      if File.exists?(filename)
        puts "Error: file #{filename} already exists."
        exit 1
      end

      empty_safe = "# safe created on #{Date.today}\n"

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        password = Cipher::check_password
        new_string = Cipher::encrypt empty_safe, password
      else
        new_string = empty_safe
      end

      FileOps::backup(filename) if File.exists?(filename)
      FileOps::save filename, new_string

      puts "New safe created in #{filename}"
    end
  end

  ##############################################################################
  command :list do
    banner "pwss list [options]"
    description "List all entries of a file (e.g., to decrypt or batch process)"

    on "-f", "--filename=", "Password file to use."

    run do |opts, args|
      cmd = "list"

      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      Pwss::list entries
    end
  end

  ##############################################################################
  command :get do
    banner "pwss get [options] string"
    description "Get password for entry matching <string> in the title field"

    on "-f", "--filename=", "Password file to use"
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive)", as: Integer
    on "--stdout", "Output the password to standard output"
    on "--select=", "Select the N-th matching entry", as: Integer

    run  do |opts, args|
      cmd = "get"

      filename = opts.to_hash[:filename] || DEFAULT_FILENAME
      waiting = opts.to_hash[:wait] || DEFAULT_SECS
      stdout_opt = opts.to_hash[:stdout]
      entry_no = opts.to_hash[:select] || nil

      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      password = Pwss::get args.join(" "), entries, entry_no

      if password then
        stdout_opt ? printf("%s", password) : Cipher.password_to_clipboard(password, waiting)
      end

    end
  end


  ##############################################################################
  command :add do
    banner "pwss add [options] [entry title]"
    description "Add an entry and copy its password in the clipboard"

    on "-f", "--filename=", "Password file to use"
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive)", as: Integer
    
    on "-e", "--entry=", "Create an entry of type TYPE (Entry, CreditCard, BankAccount, SoftwareLicense).\n                        Default to 'Entry', which is good enough for websites credentials"

    on "-g", "--generate=", "Generate a random password of given length.", as: Integer
    on "-a", "--alnum", "Use only alphanumeric chars for the randomly generated password"

    run do |opts, args|
      cmd = "add"
      add opts, args
    end
  end

  command :new do
    banner "pwss new [options] [entry title]"
    description "An alias for add"

    on "-f", "--filename=", "Password file to use"
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive)", as: Integer
    
    on "-e", "--entry=", "Create an entry of type TYPE (Entry, CreditCard, BankAccount, SoftwareLicense).\n                        Default to 'Entry', which is good enough for websites credentials"

    on "-g", "--generate=", "Generate a random password of given length.", as: Integer
    on "-a", "--alnum", "Use only alphanumeric chars for the randomly generated password"

    run do |opts, args|
      cmd = "new"
      add opts, args
    end
  end

  ##############################################################################
  command :update do
    banner "pwss update [options] string"
    description "Update given field of user-selected entry matching <string>"

    on "-f", "--filename=", "Password file to use"
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive)", as: Integer
    on "-g", "--generate=", "Generate a random password of given length", as: Integer
    on "-a", "--alnum", "Use only alphanumeric chars for the randomly generated password"
    on "--field=", 'Field to update'
    on "-p", "--password", "an alias for --field password"

    run do |opts, args|
      cmd = "update"

      filename = opts.to_hash[:filename] || DEFAULT_FILENAME
      waiting  = opts.to_hash[:wait]     || DEFAULT_SECS
      length   = opts.to_hash[:generate] || 0
      alnum    = opts.to_hash[:alnum]
      field    = opts.to_hash[:password] ? "password" : opts.to_hash[:field]

      if not field then
        puts "Please specify a field to update (used --field ... or -p)"
        exit 1
      end

      string, password = file2string filename

      # load entries and update 
      entries = YAML::load(string) || Array.new

      if field == "password" then
        # update password
        entries, entry_password = Pwss::update args.join(" "), entries, length, alnum
      else
        entries, entry_password = Pwss::update_field args.join(" "), entries, field
      end

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry updated."

      # copy to clipboard the new password
      if entry_password
        Cipher.password_to_clipboard entry_password, waiting
      end
    end
  end    

  ##############################################################################
  # Look for entries matching string, offer the user to select one of the
  # matching entries, and destroy the entry.  
  # The command asks for confirmation even if there is only one matching entry.
  # Destroyed entries cannot be recovered (unless you dig in the backup file).
  command :destroy do
    banner "pwss destroy [options] string"
    description "Destroy a user-selected entry matching <string>, after user confirmation."

    on "-f", "--filename=", "Password file to create. Use extension '.enc' to encrypt it."

    run do |opts, args|
      cmd = "destroy"
      
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      string, password = file2string filename
      entries = YAML::load(string)

      entries = Pwss::destroy args.join(" "), entries
      
      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry deleted."
    end
  end

  ##############################################################################
  # OPERATIONS ON PASSWORD FILES
  ##############################################################################

  ##############################################################################
  command :encrypt do
    banner "pwss encrypt [options]"
    description "Encrypt a password safe"
    
    on "-f", "--filename=", "Password file to encrypt. Write to <file>.enc."

    run do |opts, _|
      cmd = "encrypt"
      
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME.sub(/\.enc$/, "")

      if not File.exists?(filename)
        puts "Error: file #{filename} does not exist."
        exit 1
      end

      password = Cipher::check_password
      data = FileOps::load filename
      encrypted = Cipher::encrypt data, password

      enc_filename = filename + ".enc"

      if File.exists?(enc_filename)
        FileOps::backup enc_filename
        puts "Warning: existing #{enc_filename} backupped to #{enc_filename}~"
      end
      FileOps::save enc_filename, encrypted
      puts "An encrypted copy now lives in #{enc_filename}"
      puts "You might want to check everything is ok and delete the plain file: #{filename}"
    end
  end

  ##############################################################################
  command :decrypt do
    banner "pwss decrypt [options]"
    description "Decrypt a password safe"

    on "-f", "--filename=", "Password file to decrypt.  Write to <file>, without '.enc'."

    run do |opts, _|
      cmd = "decrypt"

      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      if not File.exists?(filename)
        puts "Error: file #{filename} does not exist."
        exit 1
      end

      password = Cipher::ask_password
      data = FileOps::load filename
      decrypted = Cipher::decrypt data, password

      dec_filename = filename.sub(/\.enc$/,"")
      if File.exists?(dec_filename)
        FileOps::backup dec_filename
        puts "Warning: existing #{dec_filename} backupped to #{dec_filename}~"
      end
      
      FileOps::save dec_filename, decrypted
      puts "A decrypted copy now lives in #{dec_filename}"
      puts "You might want to check everything is ok and delete #{filename}, if you wish."
    end
  end

end

if cmd == nil then
  puts opts
end
