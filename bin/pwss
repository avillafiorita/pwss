#!/usr/bin/env ruby

require 'fileutils'
require 'slop'
require 'date'

require "pwss"
require "pwss/version"
require "pwss/cipher"
require "pwss/entry"
require "pwss/credit_card"
require "pwss/bank_account"
require "pwss/software_license"
require "pwss/fileops"

# load filename and decrypt, if necessary
# return the filename as string and the password (in case you need to save)
def file2string filename
  string = FileOps::load filename
  if FileOps::encrypted? filename then
    password = Cipher::ask_password
    string = Cipher::decrypt string, password
  end
  [string, password]
end


version = Pwss::VERSION
man = <<EOS
NAME
  pwss -- A command-line password manager

SYNOPSYS
  pwss [-h|-v]
  pwss command [options] [args]

DESCRIPTION
  PWSS is a password manager, in the spirit of pws.

  Features:

  * PWSS manages password files.  A password file store passwords and other
    sensitive information

  * Entries in a password file can be of the following pre-defined types:
    Entry, CreditCard, BankAccount, SoftwareLicense

  * Information stored for each type:

    - Entry:           title, username, password, url, description
    - CreditCard:      title, issuer, name_on_card, card_number, valid_from, 
                       valid_till, verification_number, pin, url, notes
    - BankAccount:     title, name, iban, url, description
    - SoftwareLicense: title, version, license_number, licensed_to,
                       email, purchased_on

  * CRUD (create, read, update, delete) commands are available to
    operate on entries and password files

  * The user can manage different password files (e.g., work, personal)
  * Password files can be encrypted
  * Encrypted password files can be decrypted, for instance, to batch process
    entries, to migrate to another tool, or to manually edit entries
  * Entries are human-readable (and editable), when the password file is not
    encrypted

EXAMPLES
  pwss -h                               # get syntax of each command

  # scenario
  pwss init -f a.enc                    # generate an encrypted safe a.enc
  pwss add -f a.enc -g 16 -a            # add an entry (generating a password)
  pwss get -f a.enc my secret account   # find an entry

VERSION
  This is version #{version}

LICENSE
  MIT

SEE ALSO
  pwss -h
  https://github.com/avillafiorita/pwss
EOS



#
# Main App Starts Here!
#
opts = Slop.parse :help => true do
  # the default filename
  DEFAULT_FILENAME = File.join(Dir.home, ".pwss.yaml.enc")
  # the default number of seconds password is available in the clipboard
  DEFAULT_SECS = 30

  banner "pwss [-h|-v]\npwss command [options] [args]"

  ##############################################################################
  on "-v", "--version", 'Print version information' do
    puts "pwss version #{version}"
  end

  ##############################################################################
  command :help do
    banner "pwss help"
    description "Print detailed information about how to use pwss"

    run do |_, _|
      puts man
    end
  end

  ##############################################################################
  command :init do
    banner "pwss init [options]"
    description "Init a new password file"

    on "-f", "--filename=", "Password file to create. Use extension '.enc' to encrypt it."

    run do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      if File.exists?(filename)
        puts "Error: file #{filename} already exists."
        exit 1
      end

      empty_safe = "# safe created on #{Date.today}\n"

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        password = Cipher::check_password
        new_string = Cipher::encrypt empty_safe, password
      else
        new_string = empty_safe
      end

      FileOps::backup(filename) if File.exists?(filename)
      FileOps::save filename, new_string

      puts "New safe created in #{filename}"
    end
  end

  ##############################################################################
  command :list do
    banner "pwss list [options]"
    description "List all entries of a file (e.g., to decrypt or batch process)"

    on "-f", "--filename=", "Password file to use."

    run do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      Pwss::list entries
    end
  end

  ##############################################################################
  command :get do
    banner "pwss get [options] string"
    description "Get password for entry matching <string> in the title field"

    on "-f", "--filename=", "Password file to use."
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive).", as: Integer

    run  do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME
      waiting = opts.to_hash[:wait] || DEFAULT_SECS

      string, _ = file2string filename
      entries = YAML::load(string) || Array.new

      password = Pwss::get args.join(" "), entries
      if password
        Cipher.password_to_clipboard password, waiting 
      end
    end
  end


  ##############################################################################
  command :add do
    banner "pwss add [options]"
    description "Add an entry and copy its password in the clipboard"

    on "-f", "--filename=", "Password file to use."
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive).", as: Integer
      
    on "-e", "--entry=", "Create an entry of type TYPE (Entry, CreditCard, BankAccount, SoftwareLicense).\n                        Default to 'Entry', which is good enough for websites credentials."

    on "-g", "--generate=", "Generate a random password of given length.", as: Integer
    on "-a", "--alnum", "Use only alphanumeric chars for the randomly generated password."

    run do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME
      waiting  = opts.to_hash[:wait]     || DEFAULT_SECS
      length   = opts.to_hash[:generate] || 0
      type     = opts.to_hash[:type]     || "Entry"
      alnum    = opts.to_hash[:alnum]

      string, password = file2string filename

      puts "Adding an entry of type: #{type}"
      # ask for a new entry
      pe = eval("Pwss::" + type).new
      pe.ask length, alnum

      # add the entry to the safe
      entries = YAML::load(string) || Array.new
      entries << pe.entry

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry added."
      
      # make password available in the clipboard, if there is a password to make available
      if pe.entry["password"] 
        Cipher.password_to_clipboard pe.entry["password"], waiting
      end
    end
  end

  ##############################################################################
  command :update do
    banner "pwss update [options] string"
    description "Update given field of user-selected entry matching <string>"

    on "-f", "--filename=", "Password file to use."
    on "-w", "--wait=", "Seconds password is available in the clipboard (0 = interactive).", as: Integer
    on "-g", "--generate=", "Generate a random password of given length.", as: Integer
    on "-a", "--alnum", "Use only alphanumeric chars for the randomly generated password."
    on '--field=', 'Field to update (if not specified, update the password field).'

    run do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME
      waiting  = opts.to_hash[:wait]     || DEFAULT_SECS
      length   = opts.to_hash[:generate] || 0
      alnum    = opts.to_hash[:alnum]
      field    = opts.to_hash[:field]

      string, password = file2string filename

      # load entries and update 
      entries = YAML::load(string) || Array.new

      if field then
        entries, entry_password = Pwss::update_field args.join(" "), entries, field
      else
        # update password
        entries, entry_password = Pwss::update args.join(" "), entries, length, alnum
      end

      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry updated."

      # copy to clipboard the new password
      if entry_password
        Cipher.password_to_clipboard entry_password, waiting
      end
    end
  end    

  ##############################################################################
  # Look for entries matching string, offer the user to select one of the
  # matching entries, and destroy the entry.  
  # The command asks for confirmation even if there is only one matching entry.
  # Destroyed entries cannot be recovered (unless you dig in the backup file).
  command :destroy do
    banner "pwss destroy [options] string"
    description "Destroy a user-selected entry matching <string>, after user confirmation."

    on "-f", "--filename=", "Password file to create. Use extension '.enc' to encrypt it."

    run do |opts, args|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      string, password = file2string filename
      entries = YAML::load(string)

      entries = Pwss::destroy args.join(" "), entries
      
      # check status of input file and encrypt if necessary
      if FileOps::encrypted? filename then
        new_string = Cipher::encrypt entries.to_yaml, password
      else
        new_string = entries.to_yaml
      end

      FileOps::backup filename
      FileOps::save filename, new_string

      puts "Entry deleted."
    end
  end

  ##############################################################################
  # OPERATIONS ON PASSWORD FILES
  ##############################################################################

  ##############################################################################
  command :encrypt do
    banner "pwss encrypt [options]"
    description "Encrypt a password safe"
    
    on "-f", "--filename=", "Password file to encrypt. Write to <file>.enc."

    run do |opts, _|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME.sub(/\.enc$/, "")

      if not File.exists?(filename)
        puts "Error: file #{filename} does not exist."
        exit 1
      end

      password = Cipher::check_password
      data = FileOps::load filename
      encrypted = Cipher::encrypt data, password

      enc_filename = filename + ".enc"

      if File.exists?(enc_filename)
        FileOps::backup enc_filename
        puts "Warning: existing #{enc_filename} backupped to #{enc_filename}~"
      end
      FileOps::save enc_filename, encrypted
      puts "An encrypted copy now lives in #{enc_filename}"
      puts "You might want to check everything is ok and delete the plain file: #{filename}"
    end
  end

  ##############################################################################
  command :decrypt do
    banner "pwss decrypt [options]"
    description "Decrypt a password safe"

    on "-f", "--filename=", "Password file to decrypt.  Write to <file>, without '.enc'."

    run do |opts, _|
      filename = opts.to_hash[:filename] || DEFAULT_FILENAME

      if not File.exists?(filename)
        puts "Error: file #{filename} does not exist."
        exit 1
      end

      password = Cipher::ask_password
      data = FileOps::load filename
      decrypted = Cipher::decrypt data, password

      dec_filename = filename.sub(/\.enc$/,"")
      if File.exists?(dec_filename)
        FileOps::backup dec_filename
        puts "Warning: existing #{dec_filename} backupped to #{dec_filename}~"
      end
            
      FileOps::save dec_filename, decrypted
      puts "A decrypted copy now lives in #{dec_filename}"
      puts "You might want to check everything is ok and delete #{filename}, if you wish."
    end
  end

end
